/* automatically generated by rust-bindgen 0.59.1 */

pub type conditional_type<_If> = _If;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pair<_T1, _T2> {
    pub first: _T1,
    pub second: _T2,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
}
pub type pair_first_type<_T1> = _T1;
pub type pair_second_type<_T2> = _T2;
pub type pair__EnableB = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pair__CheckArgs {
    pub _address: u8,
}
pub type pair__CheckArgsDep = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pair__CheckTupleLikeConstructor {
    pub _address: u8,
}
pub type pair__CheckTLC = u8;
pub type HHKey = [u64; 4usize];
pub type HHResult128 = [u64; 2usize];
pub type HHResult256 = [u64; 4usize];
extern "C" {
    pub fn HighwayHash64(key: *mut u64, bytes: *const ::std::os::raw::c_char, size: u64) -> u64;
}
extern "C" {
    pub fn HighwayHash64_TargetPortable(
        key: *mut u64,
        bytes: *const ::std::os::raw::c_char,
        size: u64,
    ) -> u64;
}
extern "C" {
    pub fn HighwayHash64_TargetSSE41(
        key: *mut u64,
        bytes: *const ::std::os::raw::c_char,
        size: u64,
    ) -> u64;
}
extern "C" {
    pub fn HighwayHash64_TargetAVX2(
        key: *mut u64,
        bytes: *const ::std::os::raw::c_char,
        size: u64,
    ) -> u64;
}
extern "C" {
    pub fn HighwayHash64_TargetVSX(
        key: *mut u64,
        bytes: *const ::std::os::raw::c_char,
        size: u64,
    ) -> u64;
}
pub type uint32 = u32;
pub type uint64 = u64;
pub type uint128 = pair<uint64, uint64>;
extern "C" {
    #[link_name = "\u{1}__Z18CityHash32WithSeedPKcmj"]
    pub fn CityHash32WithSeed(
        buf: *const ::std::os::raw::c_char,
        len: usize,
        seed: uint32,
    ) -> uint32;
}
extern "C" {
    #[link_name = "\u{1}__Z10CityHash64PKcm"]
    pub fn CityHash64(buf: *const ::std::os::raw::c_char, len: usize) -> uint64;
}
extern "C" {
    #[link_name = "\u{1}__Z18CityHash64WithSeedPKcmy"]
    pub fn CityHash64WithSeed(
        buf: *const ::std::os::raw::c_char,
        len: usize,
        seed: uint64,
    ) -> uint64;
}
extern "C" {
    #[link_name = "\u{1}__Z19CityHash64WithSeedsPKcmyy"]
    pub fn CityHash64WithSeeds(
        buf: *const ::std::os::raw::c_char,
        len: usize,
        seed0: uint64,
        seed1: uint64,
    ) -> uint64;
}
extern "C" {
    #[link_name = "\u{1}__Z11CityHash128PKcm"]
    pub fn CityHash128(s: *const ::std::os::raw::c_char, len: usize) -> uint128;
}
extern "C" {
    #[link_name = "\u{1}__Z19CityHash128WithSeedPKcmNSt3__14pairIyyEE"]
    pub fn CityHash128WithSeed(
        s: *const ::std::os::raw::c_char,
        len: usize,
        seed: uint128,
    ) -> uint128;
}
extern "C" {
    #[link_name = "\u{1}__Z14CityHashCrc128PKcm"]
    pub fn CityHashCrc128(s: *const ::std::os::raw::c_char, len: usize) -> uint128;
}
extern "C" {
    #[link_name = "\u{1}__Z22CityHashCrc128WithSeedPKcmNSt3__14pairIyyEE"]
    pub fn CityHashCrc128WithSeed(
        s: *const ::std::os::raw::c_char,
        len: usize,
        seed: uint128,
    ) -> uint128;
}
extern "C" {
    #[link_name = "\u{1}__Z14CityHashCrc256PKcmPy"]
    pub fn CityHashCrc256(s: *const ::std::os::raw::c_char, len: usize, result: *mut uint64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uint128_c_t {
    pub a: u64,
    pub b: u64,
}
#[test]
fn bindgen_test_layout_uint128_c_t() {
    assert_eq!(
        ::std::mem::size_of::<uint128_c_t>(),
        16usize,
        concat!("Size of: ", stringify!(uint128_c_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uint128_c_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uint128_c_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint128_c_t>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uint128_c_t),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<uint128_c_t>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uint128_c_t),
            "::",
            stringify!(b)
        )
    );
}
extern "C" {
    pub fn farmhash(s: *const ::std::os::raw::c_char, len: usize) -> usize;
}
extern "C" {
    pub fn farmhash32(s: *const ::std::os::raw::c_char, len: usize) -> u32;
}
extern "C" {
    pub fn farmhash32_with_seed(s: *const ::std::os::raw::c_char, len: usize, seed: u32) -> u32;
}
extern "C" {
    pub fn farmhash64(s: *const ::std::os::raw::c_char, len: usize) -> u64;
}
extern "C" {
    pub fn farmhash64_with_seed(s: *const ::std::os::raw::c_char, len: usize, seed: u64) -> u64;
}
extern "C" {
    pub fn farmhash64_with_seeds(
        s: *const ::std::os::raw::c_char,
        len: usize,
        seed0: u64,
        seed1: u64,
    ) -> u64;
}
extern "C" {
    pub fn farmhash128(s: *const ::std::os::raw::c_char, len: usize) -> uint128_c_t;
}
extern "C" {
    pub fn farmhash128_with_seed(
        s: *const ::std::os::raw::c_char,
        len: usize,
        seed: uint128_c_t,
    ) -> uint128_c_t;
}
extern "C" {
    pub fn farmhash_fingerprint32(s: *const ::std::os::raw::c_char, len: usize) -> u32;
}
extern "C" {
    pub fn farmhash_fingerprint64(s: *const ::std::os::raw::c_char, len: usize) -> u64;
}
extern "C" {
    pub fn farmhash_fingerprint128(s: *const ::std::os::raw::c_char, len: usize) -> uint128_c_t;
}
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
extern "C" {
    #[link_name = "\u{1}__ZL15MeowShiftAdjust"]
    pub static mut MeowShiftAdjust: [::std::os::raw::c_uchar; 32usize];
}
extern "C" {
    #[link_name = "\u{1}__ZL11MeowMaskLen"]
    pub static mut MeowMaskLen: [::std::os::raw::c_uchar; 32usize];
}
extern "C" {
    #[link_name = "\u{1}__ZL15MeowDefaultSeed"]
    pub static mut MeowDefaultSeed: [::std::os::raw::c_uchar; 128usize];
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct meow_state {
    pub xmm0: __m128i,
    pub xmm1: __m128i,
    pub xmm2: __m128i,
    pub xmm3: __m128i,
    pub xmm4: __m128i,
    pub xmm5: __m128i,
    pub xmm6: __m128i,
    pub xmm7: __m128i,
    pub TotalLengthInBytes: ::std::os::raw::c_ulonglong,
    pub BufferLen: ::std::os::raw::c_uint,
    pub Buffer: [::std::os::raw::c_uchar; 256usize],
    pub Pad: [__m128i; 2usize],
}
#[test]
fn bindgen_test_layout_meow_state() {
    assert_eq!(
        ::std::mem::size_of::<meow_state>(),
        432usize,
        concat!("Size of: ", stringify!(meow_state))
    );
    assert_eq!(
        ::std::mem::align_of::<meow_state>(),
        16usize,
        concat!("Alignment of ", stringify!(meow_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm2 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm3 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm4 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm5 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm6 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).xmm7 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(xmm7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).TotalLengthInBytes as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(TotalLengthInBytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).BufferLen as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(BufferLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).Buffer as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(Buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<meow_state>())).Pad as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(meow_state),
            "::",
            stringify!(Pad)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}__Z13metrohash64_1PKhyjPh"]
    pub fn metrohash64_1(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z13metrohash64_2PKhyjPh"]
    pub fn metrohash64_2(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z16metrohash64crc_1PKhyjPh"]
    pub fn metrohash64crc_1(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z16metrohash64crc_2PKhyjPh"]
    pub fn metrohash64crc_2(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z14metrohash128_1PKhyjPh"]
    pub fn metrohash128_1(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z14metrohash128_2PKhyjPh"]
    pub fn metrohash128_2(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z17metrohash128crc_1PKhyjPh"]
    pub fn metrohash128crc_1(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z17metrohash128crc_2PKhyjPh"]
    pub fn metrohash128crc_2(key: *const u8, len: u64, seed: u32, out: *mut u8);
}
extern "C" {
    #[link_name = "\u{1}__Z11MurmurHash1PKvij"]
    pub fn MurmurHash1(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__Z18MurmurHash1AlignedPKvij"]
    pub fn MurmurHash1Aligned(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__Z11MurmurHash2PKvij"]
    pub fn MurmurHash2(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__Z13MurmurHash64APKviy"]
    pub fn MurmurHash64A(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u64,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__Z13MurmurHash64BPKviy"]
    pub fn MurmurHash64B(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u64,
    ) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__Z12MurmurHash2APKvij"]
    pub fn MurmurHash2A(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__Z18MurmurHashNeutral2PKvij"]
    pub fn MurmurHashNeutral2(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__Z18MurmurHashAligned2PKvij"]
    pub fn MurmurHashAligned2(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__Z18MurmurHash3_x86_32PKvijPv"]
    pub fn MurmurHash3_x86_32(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
        out: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z19MurmurHash3_x86_128PKvijPv"]
    pub fn MurmurHash3_x86_128(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
        out: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z19MurmurHash3_x64_128PKvijPv"]
    pub fn MurmurHash3_x64_128(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: u32,
        out: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union t1ha_state256 {
    pub bytes: [u8; 32usize],
    pub u32_: [u32; 8usize],
    pub u64_: [u64; 4usize],
    pub n: t1ha_state256__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct t1ha_state256__bindgen_ty_1 {
    pub a: u64,
    pub b: u64,
    pub c: u64,
    pub d: u64,
}
#[test]
fn bindgen_test_layout_t1ha_state256__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<t1ha_state256__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(t1ha_state256__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<t1ha_state256__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(t1ha_state256__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256__bindgen_ty_1>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256__bindgen_ty_1),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256__bindgen_ty_1>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256__bindgen_ty_1),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256__bindgen_ty_1>())).c as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256__bindgen_ty_1),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256__bindgen_ty_1>())).d as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
}
#[test]
fn bindgen_test_layout_t1ha_state256() {
    assert_eq!(
        ::std::mem::size_of::<t1ha_state256>(),
        32usize,
        concat!("Size of: ", stringify!(t1ha_state256))
    );
    assert_eq!(
        ::std::mem::align_of::<t1ha_state256>(),
        8usize,
        concat!("Alignment of ", stringify!(t1ha_state256))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256>())).bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256>())).u32_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256>())).u64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256),
            "::",
            stringify!(u64_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_state256>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_state256),
            "::",
            stringify!(n)
        )
    );
}
pub type t1ha_state256_t = t1ha_state256;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct t1ha_context {
    pub state: t1ha_state256_t,
    pub buffer: t1ha_state256_t,
    pub partial: usize,
    pub total: u64,
}
#[test]
fn bindgen_test_layout_t1ha_context() {
    assert_eq!(
        ::std::mem::size_of::<t1ha_context>(),
        96usize,
        concat!("Size of: ", stringify!(t1ha_context))
    );
    assert_eq!(
        ::std::mem::align_of::<t1ha_context>(),
        32usize,
        concat!("Alignment of ", stringify!(t1ha_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_context>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_context>())).buffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_context),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_context>())).partial as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_context),
            "::",
            stringify!(partial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<t1ha_context>())).total as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(t1ha_context),
            "::",
            stringify!(total)
        )
    );
}
pub type t1ha_context_t = t1ha_context;
extern "C" {
    pub fn t1ha2_atonce(data: *const ::std::os::raw::c_void, length: usize, seed: u64) -> u64;
}
extern "C" {
    pub fn t1ha2_atonce128(
        extra_result: *mut u64,
        data: *const ::std::os::raw::c_void,
        length: usize,
        seed: u64,
    ) -> u64;
}
extern "C" {
    pub fn t1ha2_init(ctx: *mut t1ha_context_t, seed_x: u64, seed_y: u64);
}
extern "C" {
    pub fn t1ha2_update(
        ctx: *mut t1ha_context_t,
        data: *const ::std::os::raw::c_void,
        length: usize,
    );
}
extern "C" {
    pub fn t1ha2_final(ctx: *mut t1ha_context_t, extra_result: *mut u64) -> u64;
}
extern "C" {
    pub fn t1ha1_le(data: *const ::std::os::raw::c_void, length: usize, seed: u64) -> u64;
}
extern "C" {
    pub fn t1ha1_be(data: *const ::std::os::raw::c_void, length: usize, seed: u64) -> u64;
}
pub type t1ha0_function_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void, arg2: usize, arg3: u64) -> u64,
>;
extern "C" {
    pub fn t1ha0_resolve() -> t1ha0_function_t;
}
pub type wyhashmap_t = u64;
extern "C" {
    #[doc = " @brief Obtains the xxHash version."]
    #[doc = ""]
    #[doc = " This is only useful when xxHash is compiled as a shared library, as it is"]
    #[doc = " independent of the version defined in the header."]
    #[doc = ""]
    #[doc = " @return `XXH_VERSION_NUMBER` as of when the libray was compiled."]
    pub fn XXH_versionNumber() -> ::std::os::raw::c_uint;
}
pub const XXH_errorcode_XXH_OK: XXH_errorcode = 0;
pub const XXH_errorcode_XXH_ERROR: XXH_errorcode = 1;
pub type XXH_errorcode = ::std::os::raw::c_uint;
pub type XXH32_hash_t = u32;
extern "C" {
    #[doc = " @brief Calculates the 32-bit hash of @p input using xxHash32."]
    #[doc = ""]
    #[doc = " Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark): 5.4 GB/s"]
    #[doc = ""]
    #[doc = " @param input The block of data to be hashed, at least @p length bytes in size."]
    #[doc = " @param length The length of @p input, in bytes."]
    #[doc = " @param seed The 32-bit seed to alter the hash's output predictably."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "   The memory between @p input and @p input + @p length must be valid,"]
    #[doc = "   readable, contiguous memory. However, if @p length is `0`, @p input may be"]
    #[doc = "   `NULL`. In C++, this also must be *TriviallyCopyable*."]
    #[doc = ""]
    #[doc = " @return The calculated 32-bit hash value."]
    #[doc = ""]
    #[doc = " @see"]
    #[doc = "    XXH64(), XXH3_64bits_withSeed(), XXH3_128bits_withSeed(), XXH128():"]
    #[doc = "    Direct equivalents for the other variants of xxHash."]
    #[doc = " @see"]
    #[doc = "    XXH32_createState(), XXH32_update(), XXH32_digest(): Streaming version."]
    pub fn XXH32(
        input: *const ::std::os::raw::c_void,
        length: usize,
        seed: XXH32_hash_t,
    ) -> XXH32_hash_t;
}
#[doc = " @typedef struct XXH32_state_s XXH32_state_t"]
#[doc = " @brief The opaque state struct for the XXH32 streaming API."]
#[doc = ""]
#[doc = " @see XXH32_state_s for details."]
pub type XXH32_state_t = XXH32_state_s;
extern "C" {
    #[doc = " @brief Allocates an @ref XXH32_state_t."]
    #[doc = ""]
    #[doc = " Must be freed with XXH32_freeState()."]
    #[doc = " @return An allocated XXH32_state_t on success, `NULL` on failure."]
    pub fn XXH32_createState() -> *mut XXH32_state_t;
}
extern "C" {
    #[doc = " @brief Frees an @ref XXH32_state_t."]
    #[doc = ""]
    #[doc = " Must be allocated with XXH32_createState()."]
    #[doc = " @param statePtr A pointer to an @ref XXH32_state_t allocated with @ref XXH32_createState()."]
    #[doc = " @return XXH_OK."]
    pub fn XXH32_freeState(statePtr: *mut XXH32_state_t) -> XXH_errorcode;
}
extern "C" {
    #[doc = " @brief Copies one @ref XXH32_state_t to another."]
    #[doc = ""]
    #[doc = " @param dst_state The state to copy to."]
    #[doc = " @param src_state The state to copy from."]
    #[doc = " @pre"]
    #[doc = "   @p dst_state and @p src_state must not be `NULL` and must not overlap."]
    pub fn XXH32_copyState(dst_state: *mut XXH32_state_t, src_state: *const XXH32_state_t);
}
extern "C" {
    #[doc = " @brief Resets an @ref XXH32_state_t to begin a new hash."]
    #[doc = ""]
    #[doc = " This function resets and seeds a state. Call it before @ref XXH32_update()."]
    #[doc = ""]
    #[doc = " @param statePtr The state struct to reset."]
    #[doc = " @param seed The 32-bit seed to alter the hash result predictably."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "   @p statePtr must not be `NULL`."]
    #[doc = ""]
    #[doc = " @return @ref XXH_OK on success, @ref XXH_ERROR on failure."]
    pub fn XXH32_reset(statePtr: *mut XXH32_state_t, seed: XXH32_hash_t) -> XXH_errorcode;
}
extern "C" {
    #[doc = " @brief Consumes a block of @p input to an @ref XXH32_state_t."]
    #[doc = ""]
    #[doc = " Call this to incrementally consume blocks of data."]
    #[doc = ""]
    #[doc = " @param statePtr The state struct to update."]
    #[doc = " @param input The block of data to be hashed, at least @p length bytes in size."]
    #[doc = " @param length The length of @p input, in bytes."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "   @p statePtr must not be `NULL`."]
    #[doc = " @pre"]
    #[doc = "   The memory between @p input and @p input + @p length must be valid,"]
    #[doc = "   readable, contiguous memory. However, if @p length is `0`, @p input may be"]
    #[doc = "   `NULL`. In C++, this also must be *TriviallyCopyable*."]
    #[doc = ""]
    #[doc = " @return @ref XXH_OK on success, @ref XXH_ERROR on failure."]
    pub fn XXH32_update(
        statePtr: *mut XXH32_state_t,
        input: *const ::std::os::raw::c_void,
        length: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    #[doc = " @brief Returns the calculated hash value from an @ref XXH32_state_t."]
    #[doc = ""]
    #[doc = " @note"]
    #[doc = "   Calling XXH32_digest() will not affect @p statePtr, so you can update,"]
    #[doc = "   digest, and update again."]
    #[doc = ""]
    #[doc = " @param statePtr The state struct to calculate the hash from."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "  @p statePtr must not be `NULL`."]
    #[doc = ""]
    #[doc = " @return The calculated xxHash32 value from that state."]
    pub fn XXH32_digest(statePtr: *const XXH32_state_t) -> XXH32_hash_t;
}
#[doc = " @brief Canonical (big endian) representation of @ref XXH32_hash_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH32_canonical_t {
    #[doc = "< Hash bytes, big endian"]
    pub digest: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_XXH32_canonical_t() {
    assert_eq!(
        ::std::mem::size_of::<XXH32_canonical_t>(),
        4usize,
        concat!("Size of: ", stringify!(XXH32_canonical_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH32_canonical_t>(),
        1usize,
        concat!("Alignment of ", stringify!(XXH32_canonical_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_canonical_t>())).digest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_canonical_t),
            "::",
            stringify!(digest)
        )
    );
}
extern "C" {
    #[doc = " @brief Converts an @ref XXH32_hash_t to a big endian @ref XXH32_canonical_t."]
    #[doc = ""]
    #[doc = " @param dst The @ref XXH32_canonical_t pointer to be stored to."]
    #[doc = " @param hash The @ref XXH32_hash_t to be converted."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "   @p dst must not be `NULL`."]
    pub fn XXH32_canonicalFromHash(dst: *mut XXH32_canonical_t, hash: XXH32_hash_t);
}
extern "C" {
    #[doc = " @brief Converts an @ref XXH32_canonical_t to a native @ref XXH32_hash_t."]
    #[doc = ""]
    #[doc = " @param src The @ref XXH32_canonical_t to convert."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "   @p src must not be `NULL`."]
    #[doc = ""]
    #[doc = " @return The converted hash."]
    pub fn XXH32_hashFromCanonical(src: *const XXH32_canonical_t) -> XXH32_hash_t;
}
pub type XXH64_hash_t = u64;
extern "C" {
    #[doc = " @brief Calculates the 64-bit hash of @p input using xxHash64."]
    #[doc = ""]
    #[doc = " This function usually runs faster on 64-bit systems, but slower on 32-bit"]
    #[doc = " systems (see benchmark)."]
    #[doc = ""]
    #[doc = " @param input The block of data to be hashed, at least @p length bytes in size."]
    #[doc = " @param length The length of @p input, in bytes."]
    #[doc = " @param seed The 64-bit seed to alter the hash's output predictably."]
    #[doc = ""]
    #[doc = " @pre"]
    #[doc = "   The memory between @p input and @p input + @p length must be valid,"]
    #[doc = "   readable, contiguous memory. However, if @p length is `0`, @p input may be"]
    #[doc = "   `NULL`. In C++, this also must be *TriviallyCopyable*."]
    #[doc = ""]
    #[doc = " @return The calculated 64-bit hash."]
    #[doc = ""]
    #[doc = " @see"]
    #[doc = "    XXH32(), XXH3_64bits_withSeed(), XXH3_128bits_withSeed(), XXH128():"]
    #[doc = "    Direct equivalents for the other variants of xxHash."]
    #[doc = " @see"]
    #[doc = "    XXH64_createState(), XXH64_update(), XXH64_digest(): Streaming version."]
    pub fn XXH64(
        input: *const ::std::os::raw::c_void,
        length: usize,
        seed: XXH64_hash_t,
    ) -> XXH64_hash_t;
}
#[doc = "   Streaming   *******/"]
#[doc = " @brief The opaque state struct for the XXH64 streaming API."]
#[doc = ""]
#[doc = " @see XXH64_state_s for details."]
pub type XXH64_state_t = XXH64_state_s;
extern "C" {
    pub fn XXH64_createState() -> *mut XXH64_state_t;
}
extern "C" {
    pub fn XXH64_freeState(statePtr: *mut XXH64_state_t) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH64_copyState(dst_state: *mut XXH64_state_t, src_state: *const XXH64_state_t);
}
extern "C" {
    pub fn XXH64_reset(statePtr: *mut XXH64_state_t, seed: XXH64_hash_t) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH64_update(
        statePtr: *mut XXH64_state_t,
        input: *const ::std::os::raw::c_void,
        length: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH64_digest(statePtr: *const XXH64_state_t) -> XXH64_hash_t;
}
#[doc = "   Canonical representation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH64_canonical_t {
    pub digest: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_XXH64_canonical_t() {
    assert_eq!(
        ::std::mem::size_of::<XXH64_canonical_t>(),
        8usize,
        concat!("Size of: ", stringify!(XXH64_canonical_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH64_canonical_t>(),
        1usize,
        concat!("Alignment of ", stringify!(XXH64_canonical_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_canonical_t>())).digest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_canonical_t),
            "::",
            stringify!(digest)
        )
    );
}
extern "C" {
    pub fn XXH64_canonicalFromHash(dst: *mut XXH64_canonical_t, hash: XXH64_hash_t);
}
extern "C" {
    pub fn XXH64_hashFromCanonical(src: *const XXH64_canonical_t) -> XXH64_hash_t;
}
extern "C" {
    #[doc = " @}"]
    #[doc = " ************************************************************************"]
    #[doc = " @defgroup xxh3_family XXH3 family"]
    #[doc = " @ingroup public"]
    #[doc = " @{"]
    #[doc = ""]
    #[doc = " XXH3 is a more recent hash algorithm featuring:"]
    #[doc = "  - Improved speed for both small and large inputs"]
    #[doc = "  - True 64-bit and 128-bit outputs"]
    #[doc = "  - SIMD acceleration"]
    #[doc = "  - Improved 32-bit viability"]
    #[doc = ""]
    #[doc = " Speed analysis methodology is explained here:"]
    #[doc = ""]
    #[doc = "    https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html"]
    #[doc = ""]
    #[doc = " Compared to XXH64, expect XXH3 to run approximately"]
    #[doc = " ~2x faster on large inputs and >3x faster on small ones,"]
    #[doc = " exact differences vary depending on platform."]
    #[doc = ""]
    #[doc = " XXH3's speed benefits greatly from SIMD and 64-bit arithmetic,"]
    #[doc = " but does not require it."]
    #[doc = " Any 32-bit and 64-bit targets that can run XXH32 smoothly"]
    #[doc = " can run XXH3 at competitive speeds, even without vector support."]
    #[doc = " Further details are explained in the implementation."]
    #[doc = ""]
    #[doc = " Optimized implementations are provided for AVX512, AVX2, SSE2, NEON, POWER8,"]
    #[doc = " ZVector and scalar targets. This can be controlled via the XXH_VECTOR macro."]
    #[doc = ""]
    #[doc = " XXH3 implementation is portable:"]
    #[doc = " it has a generic C90 formulation that can be compiled on any platform,"]
    #[doc = " all implementations generage exactly the same hash value on all platforms."]
    #[doc = " Starting from v0.8.0, it's also labelled \"stable\", meaning that"]
    #[doc = " any future version will also generate the same hash value."]
    #[doc = ""]
    #[doc = " XXH3 offers 2 variants, _64bits and _128bits."]
    #[doc = ""]
    #[doc = " When only 64 bits are needed, prefer invoking the _64bits variant, as it"]
    #[doc = " reduces the amount of mixing, resulting in faster speed on small inputs."]
    #[doc = " It's also generally simpler to manipulate a scalar return type than a struct."]
    #[doc = ""]
    #[doc = " The API supports one-shot hashing, streaming mode, and custom secrets."]
    pub fn XXH3_64bits(data: *const ::std::os::raw::c_void, len: usize) -> XXH64_hash_t;
}
extern "C" {
    pub fn XXH3_64bits_withSeed(
        data: *const ::std::os::raw::c_void,
        len: usize,
        seed: XXH64_hash_t,
    ) -> XXH64_hash_t;
}
extern "C" {
    pub fn XXH3_64bits_withSecret(
        data: *const ::std::os::raw::c_void,
        len: usize,
        secret: *const ::std::os::raw::c_void,
        secretSize: usize,
    ) -> XXH64_hash_t;
}
#[doc = " @brief The state struct for the XXH3 streaming API."]
#[doc = ""]
#[doc = " @see XXH3_state_s for details."]
pub type XXH3_state_t = XXH3_state_s;
extern "C" {
    pub fn XXH3_createState() -> *mut XXH3_state_t;
}
extern "C" {
    pub fn XXH3_freeState(statePtr: *mut XXH3_state_t) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_copyState(dst_state: *mut XXH3_state_t, src_state: *const XXH3_state_t);
}
extern "C" {
    pub fn XXH3_64bits_reset(statePtr: *mut XXH3_state_t) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_64bits_reset_withSeed(
        statePtr: *mut XXH3_state_t,
        seed: XXH64_hash_t,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_64bits_reset_withSecret(
        statePtr: *mut XXH3_state_t,
        secret: *const ::std::os::raw::c_void,
        secretSize: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_64bits_update(
        statePtr: *mut XXH3_state_t,
        input: *const ::std::os::raw::c_void,
        length: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_64bits_digest(statePtr: *const XXH3_state_t) -> XXH64_hash_t;
}
#[doc = " @brief The return value from 128-bit hashes."]
#[doc = ""]
#[doc = " Stored in little endian order, although the fields themselves are in native"]
#[doc = " endianness."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH128_hash_t {
    #[doc = "< `value & 0xFFFFFFFFFFFFFFFF`"]
    pub low64: XXH64_hash_t,
    #[doc = "< `value >> 64`"]
    pub high64: XXH64_hash_t,
}
#[test]
fn bindgen_test_layout_XXH128_hash_t() {
    assert_eq!(
        ::std::mem::size_of::<XXH128_hash_t>(),
        16usize,
        concat!("Size of: ", stringify!(XXH128_hash_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH128_hash_t>(),
        8usize,
        concat!("Alignment of ", stringify!(XXH128_hash_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH128_hash_t>())).low64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH128_hash_t),
            "::",
            stringify!(low64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH128_hash_t>())).high64 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH128_hash_t),
            "::",
            stringify!(high64)
        )
    );
}
extern "C" {
    pub fn XXH3_128bits(data: *const ::std::os::raw::c_void, len: usize) -> XXH128_hash_t;
}
extern "C" {
    pub fn XXH3_128bits_withSeed(
        data: *const ::std::os::raw::c_void,
        len: usize,
        seed: XXH64_hash_t,
    ) -> XXH128_hash_t;
}
extern "C" {
    pub fn XXH3_128bits_withSecret(
        data: *const ::std::os::raw::c_void,
        len: usize,
        secret: *const ::std::os::raw::c_void,
        secretSize: usize,
    ) -> XXH128_hash_t;
}
extern "C" {
    #[doc = "   Streaming"]
    pub fn XXH3_128bits_reset(statePtr: *mut XXH3_state_t) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_128bits_reset_withSeed(
        statePtr: *mut XXH3_state_t,
        seed: XXH64_hash_t,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_128bits_reset_withSecret(
        statePtr: *mut XXH3_state_t,
        secret: *const ::std::os::raw::c_void,
        secretSize: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_128bits_update(
        statePtr: *mut XXH3_state_t,
        input: *const ::std::os::raw::c_void,
        length: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH3_128bits_digest(statePtr: *const XXH3_state_t) -> XXH128_hash_t;
}
extern "C" {
    #[doc = " XXH128_isEqual():"]
    #[doc = " Return: 1 if `h1` and `h2` are equal, 0 if they are not."]
    pub fn XXH128_isEqual(h1: XXH128_hash_t, h2: XXH128_hash_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " XXH128_cmp():"]
    #[doc = ""]
    #[doc = " This comparator is compatible with stdlib's `qsort()`/`bsearch()`."]
    #[doc = ""]
    #[doc = " return: >0 if *h128_1  > *h128_2"]
    #[doc = "         =0 if *h128_1 == *h128_2"]
    #[doc = "         <0 if *h128_1  < *h128_2"]
    pub fn XXH128_cmp(
        h128_1: *const ::std::os::raw::c_void,
        h128_2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = "   Canonical representation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH128_canonical_t {
    pub digest: [::std::os::raw::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_XXH128_canonical_t() {
    assert_eq!(
        ::std::mem::size_of::<XXH128_canonical_t>(),
        16usize,
        concat!("Size of: ", stringify!(XXH128_canonical_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH128_canonical_t>(),
        1usize,
        concat!("Alignment of ", stringify!(XXH128_canonical_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH128_canonical_t>())).digest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH128_canonical_t),
            "::",
            stringify!(digest)
        )
    );
}
extern "C" {
    pub fn XXH128_canonicalFromHash(dst: *mut XXH128_canonical_t, hash: XXH128_hash_t);
}
extern "C" {
    pub fn XXH128_hashFromCanonical(src: *const XXH128_canonical_t) -> XXH128_hash_t;
}
#[doc = " @internal"]
#[doc = " @brief Structure for XXH32 streaming API."]
#[doc = ""]
#[doc = " @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,"]
#[doc = " @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined. Otherwise it is"]
#[doc = " an opaque type. This allows fields to safely be changed."]
#[doc = ""]
#[doc = " Typedef'd to @ref XXH32_state_t."]
#[doc = " Do not access the members of this struct directly."]
#[doc = " @see XXH64_state_s, XXH3_state_s"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH32_state_s {
    #[doc = "< Total length hashed, modulo 2^32"]
    pub total_len_32: XXH32_hash_t,
    #[doc = "< Whether the hash is >= 16 (handles @ref total_len_32 overflow)"]
    pub large_len: XXH32_hash_t,
    #[doc = "< First accumulator lane"]
    pub v1: XXH32_hash_t,
    #[doc = "< Second accumulator lane"]
    pub v2: XXH32_hash_t,
    #[doc = "< Third accumulator lane"]
    pub v3: XXH32_hash_t,
    #[doc = "< Fourth accumulator lane"]
    pub v4: XXH32_hash_t,
    #[doc = "< Internal buffer for partial reads. Treated as unsigned char[16]."]
    pub mem32: [XXH32_hash_t; 4usize],
    #[doc = "< Amount of data in @ref mem32"]
    pub memsize: XXH32_hash_t,
    #[doc = "< Reserved field. Do not read or write to it, it may be removed."]
    pub reserved: XXH32_hash_t,
}
#[test]
fn bindgen_test_layout_XXH32_state_s() {
    assert_eq!(
        ::std::mem::size_of::<XXH32_state_s>(),
        48usize,
        concat!("Size of: ", stringify!(XXH32_state_s))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH32_state_s>(),
        4usize,
        concat!("Alignment of ", stringify!(XXH32_state_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).total_len_32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(total_len_32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).large_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(large_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).v1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(v1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).v2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(v2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).v3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(v3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).v4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(v4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).mem32 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(mem32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).memsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(memsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH32_state_s>())).reserved as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " @internal"]
#[doc = " @brief Structure for XXH64 streaming API."]
#[doc = ""]
#[doc = " @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,"]
#[doc = " @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined. Otherwise it is"]
#[doc = " an opaque type. This allows fields to safely be changed."]
#[doc = ""]
#[doc = " Typedef'd to @ref XXH64_state_t."]
#[doc = " Do not access the members of this struct directly."]
#[doc = " @see XXH32_state_s, XXH3_state_s"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH64_state_s {
    #[doc = "< Total length hashed. This is always 64-bit."]
    pub total_len: XXH64_hash_t,
    #[doc = "< First accumulator lane"]
    pub v1: XXH64_hash_t,
    #[doc = "< Second accumulator lane"]
    pub v2: XXH64_hash_t,
    #[doc = "< Third accumulator lane"]
    pub v3: XXH64_hash_t,
    #[doc = "< Fourth accumulator lane"]
    pub v4: XXH64_hash_t,
    #[doc = "< Internal buffer for partial reads. Treated as unsigned char[32]."]
    pub mem64: [XXH64_hash_t; 4usize],
    #[doc = "< Amount of data in @ref mem64"]
    pub memsize: XXH32_hash_t,
    #[doc = "< Reserved field, needed for padding anyways"]
    pub reserved32: XXH32_hash_t,
    #[doc = "< Reserved field. Do not read or write to it, it may be removed."]
    pub reserved64: XXH64_hash_t,
}
#[test]
fn bindgen_test_layout_XXH64_state_s() {
    assert_eq!(
        ::std::mem::size_of::<XXH64_state_s>(),
        88usize,
        concat!("Size of: ", stringify!(XXH64_state_s))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH64_state_s>(),
        8usize,
        concat!("Alignment of ", stringify!(XXH64_state_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).total_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(total_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).v1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(v1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).v2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(v2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).v3 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(v3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).v4 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(v4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).mem64 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(mem64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).memsize as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(memsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).reserved32 as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(reserved32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH64_state_s>())).reserved64 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(reserved64)
        )
    );
}
#[doc = " @internal"]
#[doc = " @brief Structure for XXH3 streaming API."]
#[doc = ""]
#[doc = " @note This is only defined when @ref XXH_STATIC_LINKING_ONLY,"]
#[doc = " @ref XXH_INLINE_ALL, or @ref XXH_IMPLEMENTATION is defined."]
#[doc = " Otherwise it is an opaque type."]
#[doc = " Never use this definition in combination with dynamic library."]
#[doc = " This allows fields to safely be changed in the future."]
#[doc = ""]
#[doc = " @note ** This structure has a strict alignment requirement of 64 bytes!! **"]
#[doc = " Do not allocate this with `malloc()` or `new`,"]
#[doc = " it will not be sufficiently aligned."]
#[doc = " Use @ref XXH3_createState() and @ref XXH3_freeState(), or stack allocation."]
#[doc = ""]
#[doc = " Typedef'd to @ref XXH3_state_t."]
#[doc = " Do never access the members of this struct directly."]
#[doc = ""]
#[doc = " @see XXH3_INITSTATE() for stack initialization."]
#[doc = " @see XXH3_createState(), XXH3_freeState()."]
#[doc = " @see XXH32_state_s, XXH64_state_s"]
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct XXH3_state_s {
    pub acc: [XXH64_hash_t; 8usize],
    pub customSecret: [::std::os::raw::c_uchar; 192usize],
    pub buffer: [::std::os::raw::c_uchar; 256usize],
    pub bufferedSize: XXH32_hash_t,
    pub reserved32: XXH32_hash_t,
    pub nbStripesSoFar: usize,
    pub totalLen: XXH64_hash_t,
    pub nbStripesPerBlock: usize,
    pub secretLimit: usize,
    pub seed: XXH64_hash_t,
    pub reserved64: XXH64_hash_t,
    pub extSecret: *const ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_XXH3_state_s() {
    assert_eq!(
        ::std::mem::size_of::<XXH3_state_s>(),
        576usize,
        concat!("Size of: ", stringify!(XXH3_state_s))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH3_state_s>(),
        64usize,
        concat!("Alignment of ", stringify!(XXH3_state_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).acc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(acc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).customSecret as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(customSecret)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).buffer as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).bufferedSize as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(bufferedSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).reserved32 as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(reserved32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).nbStripesSoFar as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(nbStripesSoFar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).totalLen as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(totalLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).nbStripesPerBlock as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(nbStripesPerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).secretLimit as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(secretLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).seed as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).reserved64 as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(reserved64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<XXH3_state_s>())).extSecret as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH3_state_s),
            "::",
            stringify!(extSecret)
        )
    );
}
extern "C" {
    pub fn XXH3_generateSecret(
        secretBuffer: *mut ::std::os::raw::c_void,
        customSeed: *const ::std::os::raw::c_void,
        customSeedSize: usize,
    );
}
extern "C" {
    pub fn XXH128(
        data: *const ::std::os::raw::c_void,
        len: usize,
        seed: XXH64_hash_t,
    ) -> XXH128_hash_t;
}
extern "C" {
    #[link_name = "\u{1}__Z7lookup3PKcij"]
    pub fn lookup3(
        key: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        initval: u32,
    ) -> u32;
}
extern "C" {
    #[link_name = "\u{1}__Z28farmhash_fingerprint_uint12811uint128_c_t"]
    pub fn farmhash_fingerprint_uint128(x: uint128_c_t) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__Z27farmhash_fingerprint_uint64y"]
    pub fn farmhash_fingerprint_uint64(x: u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__Z9mum_hash_PKvmy"]
    pub fn mum_hash_(key: *const ::std::os::raw::c_void, len: usize, seed: u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__Z16SpookyHasherHashPKvmPyS1_"]
    pub fn SpookyHasherHash(
        message: *const ::std::os::raw::c_void,
        length: usize,
        hash1: *mut uint64,
        hash2: *mut uint64,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z15SpookyHasherNewv"]
    pub fn SpookyHasherNew() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}__Z16SpookyHasherFreePv"]
    pub fn SpookyHasherFree(h: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__Z16SpookyHasherInitPvyy"]
    pub fn SpookyHasherInit(h: *mut ::std::os::raw::c_void, seed1: uint64, seed2: uint64);
}
extern "C" {
    #[link_name = "\u{1}__Z18SpookyHasherUpdatePvPKvm"]
    pub fn SpookyHasherUpdate(
        h: *mut ::std::os::raw::c_void,
        message: *const ::std::os::raw::c_void,
        length: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z17SpookyHasherFinalPvPyS0_"]
    pub fn SpookyHasherFinal(
        h: *mut ::std::os::raw::c_void,
        hash1: *mut uint64,
        hash2: *mut uint64,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z8t1ha0_64PKvmy"]
    pub fn t1ha0_64(data: *const ::std::os::raw::c_void, length: usize, seed: u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__Z14HighwayHash128PKyPKcyRA2_y"]
    pub fn HighwayHash128(
        key: *mut u64,
        bytes: *const ::std::os::raw::c_char,
        size: u64,
        hash: *mut HHResult128,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z14HighwayHash256PKyPKcyRA4_y"]
    pub fn HighwayHash256(
        key: *mut u64,
        bytes: *const ::std::os::raw::c_char,
        size: u64,
        hash: *mut HHResult256,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z8wyhash64PKvyy"]
    pub fn wyhash64(key: *const ::std::os::raw::c_void, len: u64, seed: u64) -> u64;
}
extern "C" {
    #[link_name = "\u{1}__Z11MeowHash128PKviPvS1_"]
    pub fn MeowHash128(
        key: *const ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
        seed: *mut ::std::os::raw::c_void,
        out: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z13MeowHashBeginP10meow_statePv"]
    pub fn MeowHashBegin(State: *mut meow_state, Seed128: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__Z14MeowHashUpdateP10meow_statemPv"]
    pub fn MeowHashUpdate(
        State: *mut meow_state,
        Len: usize,
        SourceInit: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}__Z11MeowHashEndP10meow_statePv"]
    pub fn MeowHashEnd(State: *mut meow_state, out: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}__Z18MeowHashExpandSeedyPvPh"]
    pub fn MeowHashExpandSeed(
        InputLen: ::std::os::raw::c_ulonglong,
        Input: *mut ::std::os::raw::c_void,
        SeedResult: *mut ::std::os::raw::c_uchar,
    );
}
#[test]
fn __bindgen_test_layout_pair_open0_uint64_uint64_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<pair<uint64, uint64>>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify ! (pair < uint64 , uint64 >)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pair<uint64, uint64>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify ! (pair < uint64 , uint64 >)
        )
    );
}
